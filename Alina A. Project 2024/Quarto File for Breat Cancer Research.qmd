---
title: "Cancerous Cells are Large in Size, and High in Concavity and Compactness"
author: "Alina Ahmed"
format: html
editor: visual
---

First I downloaded the packages I needed for my project.

```{r}
library(ggplot2)
library(dplyr)
library(janitor)
library(tidyr)
library(titanic)
library(chisquare)
library(tidyverse)
library(infer)
library(mosaic)
library(Stat2Data)
library(skimr)
library(pROC)
```

My Dataset Path I used:

```{r}
data = read.csv("/Users/alinaahmed/Documents/DRSP Lung Cancer Research/Alina A. Project 2024/Data Coding for Breast Cancer/breast_cancer_classification_data.csv")
```

Data Cleaning:

```{r}
# count null values
col_na_count <- colSums(is.na(data))
print(col_na_count)
# cleaning the column names
data = clean_names(data)
names(data)
data <- select(data, -contains("X"))
# count null values
col_na_count <- colSums(is.na(data))
print(col_na_count)
```

In order to remove possible skews/biases in the results, I took 100 samples of benign cases, as well as 100 samples of malignant cases.

```{r}
malignant_data<- filter(breast_cancer_classification_data, diagnosis == "M")
benign_data <- filter(breast_cancer_classification_data, diagnosis == "B")

# Randomly sample 100 rows from each filtered dataset
malignant_data <- sample_n(malignant_data, 100)
benign_data <- sample_n(benign_data, 100)

# Combine the samples into one dataframe
final_sample <- bind_rows(malignant_data, benign_data)
  
# Check the dimensions of the final sample
dim(data)
# Check the distribution of diagnoses in the final sample
table(data$diagnosis)

# Check the dimensions of the final sample
dim(final_sample)
# Check the distribution of diagnoses in the final sample
table(final_sample$diagnosis)
```

Bar Plot used to calculate the range of Tumor Perimeters

```{r}
ggplot(final_sample, aes(x=diagnosis, y=perimeter_mean))+ 
  geom_bar(stat="summary", fill="lightsalmon", alpha=1)+
  geom_errorbar(stat = "summary", width=0.2,colour="black", size=0.5)+
  theme_minimal() + 
  labs(title="Bar Graph of Average Tumor Perimeter Based on Diagnosis", 
       x="Diagnosis", 
       y="Perimeter Mean") + 
  ylim(0, 150)

```

Bar Plot used to calculate the range of Tumor Radius

```{r}
ggplot(final_sample, aes(x=diagnosis, y=radius_mean))+ 
  geom_bar(stat = "summary", fill ="olivedrab2") +
  geom_errorbar(stat = "summary", width=0.2,colour="black", size=0.5)+
  theme_minimal() + 
  labs(title="Bar Graph of Average Tumor Radius Based on Diagnosis", 
       x="Diagnosis", 
       y="Average Radius") + 
  ylim(0, 25)
```

Bar Plot used to calculate the range of Tumor Area

```{r}
ggplot(final_sample, aes(x=diagnosis, y=area_mean))+ 
  geom_bar(stat = "summary", fill ="plum1") +
  geom_errorbar(stat = "summary", width=0.2,colour="black", size=0.5)+
  theme_minimal() + 
  labs(title="Bar Graph of Average Tumor Area Based on Diagnosis", 
       x="Diagnosis", 
       y="Area Mean") + 
  ylim(0, 1000)
```

I wanted to figure out which variables I wanted to include in my heat map based on my findings

```{r}
selected_data <- final_sample[, c("perimeter_mean", "radius_mean", "area_mean","texture_mean", "concavity_mean", "smoothness_mean","compactness_mean", "symmetry_mean")]
correlation_matrix <- cor(selected_data)
correlation_melted <- melt(correlation_matrix)
```

```{r}
ggplot(correlation_melted, aes(x=Var2, y=Var1, fill=value)) +
  geom_tile() +
  scale_fill_gradient2(low="oldlace", high="palegreen4", mid="white", midpoint=0, limit=c(-1,1)) +
  theme_minimal() +
  labs(x="Features", y= "Features", fill="Correlation") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Code for a Chi-Square Test to figure out the exact P-value of my findings

```{r}
install.packages("chisquare")
# load the MASS package

print(str(selected_data))
selected_data

statistical_data1 = data.frame(selected_data$perimeter_mean,selected_data$concavity_mean)
statistical_data1 = table(selected_data$perimeter_mean,selected_data$concavity_mean)
print(statistical_data1)


statistical_data2 = data.frame(selected_data$perimeter_mean,selected_data$compactness_mean)
statistical_data2 = table(selected_data$perimeter_mean,selected_data$compactness_mean)
print(statistical_data2)
print(chisq.test(statistical_data2))

statistical_data3 = data.frame(selected_data$concavity_mean,selected_data$compactness_mean)
print(statistical_data3)

# applying chisq.test() function
print(chisq.test(statistical_data1))
#p-value = 0.3 for perimeter + concavity
print(chisq.test(statistical_data2))
# p-value = 0.3 for perimeter + compactness
print(chisq.test(statistical_data3))

# p-value = 1 for concavity + compactness
```

Made a training set data and testing set data (splitting).

```{r}
library(tidyverse)
library(infer)
library(mosaic)
library(Stat2Data)
library(skimr)


view(data)
set.seed(569)
which_train <- sample(1:569, size = 512, replace = FALSE)

training <- data %>%
  slice(which_train)

testing <- data %>%
  slice(-which_train)
```

K-fold cross validation test

```{r}
# Load the dataset
data <- read.csv("/Users/alinaahmed/Documents/DRSP Lung Cancer Research/Alina A. Project 2024/Data Coding for Breast Cancer/breast_cancer_classification_data.csv")

# Drop column X from the dataset
data <- data[, !(names(data) %in% "X")]

# Convert the diagnosis column to a factor
data$diagnosis <- as.factor(data$diagnosis)

str(data)

# Check for missing values
missing_counts <- sapply(data, function(x) sum(is.na(x)))
print(missing_counts)

# Remove rows with any missing values
data_clean <- na.omit(data)

# Verify that the column has been dropped
print(names(data_clean))

# Verify there are no missing values
print(sum(is.na(data_clean)))

# Set up training control for k-fold cross-validation
k <- 10
train_control <- trainControl(method = "cv", number = k)

# Train the model with cleaned data using logistic regression
model <- train(diagnosis ~ ., data = data_clean, method = "glm", family = "binomial", trControl = train_control)

print(model)
```

```{r}
library(pROC)

summary(logistic_model)

predict_reg <- predict(logistic_model,
                       test_reg, type = "response")
predict_reg

# Compute ROC curve
roc_curve <- roc(test_data$diagnosis, predictions)
plot(roc_curve)

# Print AUC
print(paste("AUC:", auc(roc_curve)))
# Plot ROC curve with additional customization
plot(roc_curve, 
     main = "ROC Curve for Diagnosis Prediction", 
     col = "black", 
     lwd = 2, 
     xlab = "False Positive Rate",  # X-axis label
     ylab = "True Positive Rate")    # Y-axis label
```
